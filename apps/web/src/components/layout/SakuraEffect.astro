---
/**
 * SakuraEffect — 轻微的樱花飘落效果
 * 使用 Canvas 实现，pointer-events: none，不影响交互
 */
---

<canvas id="sakura-canvas" aria-hidden="true"></canvas>

<script>
  function initSakura() {
    const canvas = document.getElementById('sakura-canvas') as HTMLCanvasElement | null
    if (!canvas) return
    const ctx = canvas.getContext('2d')
    if (!ctx) return

    // 避免重复初始化
    if ((canvas as any).__sakuraInit) return
    ;(canvas as any).__sakuraInit = true

    const MAX_PETALS = 18
    const COLORS = [
      'rgba(255, 183, 197, 0.55)',
      'rgba(255, 192, 203, 0.50)',
      'rgba(255, 172, 188, 0.45)',
      'rgba(248, 200, 220, 0.50)',
      'rgba(255, 210, 220, 0.40)',
    ]

    interface Petal {
      x: number
      y: number
      size: number
      speedY: number
      speedX: number
      angle: number
      spin: number
      opacity: number
      color: string
      swayOffset: number
      swaySpeed: number
    }

    let petals: Petal[] = []
    let w = 0
    let h = 0
    let animId = 0

    function resize() {
      w = window.innerWidth
      h = window.innerHeight
      canvas!.width = w
      canvas!.height = h
    }

    function createPetal(): Petal {
      return {
        x: Math.random() * w,
        y: -10 - Math.random() * 40,
        size: 4 + Math.random() * 5,
        speedY: 0.3 + Math.random() * 0.5,
        speedX: -0.1 + Math.random() * 0.2,
        angle: Math.random() * Math.PI * 2,
        spin: (Math.random() - 0.5) * 0.02,
        opacity: 0.3 + Math.random() * 0.3,
        color: COLORS[Math.floor(Math.random() * COLORS.length)]!,
        swayOffset: Math.random() * Math.PI * 2,
        swaySpeed: 0.005 + Math.random() * 0.01,
      }
    }

    function drawPetal(p: Petal) {
      ctx!.save()
      ctx!.translate(p.x, p.y)
      ctx!.rotate(p.angle)
      ctx!.globalAlpha = p.opacity
      ctx!.fillStyle = p.color

      // 花瓣形状：两个重叠的椭圆
      ctx!.beginPath()
      ctx!.ellipse(0, 0, p.size, p.size * 0.55, 0, 0, Math.PI * 2)
      ctx!.fill()

      ctx!.beginPath()
      ctx!.ellipse(p.size * 0.2, p.size * 0.1, p.size * 0.8, p.size * 0.4, Math.PI * 0.25, 0, Math.PI * 2)
      ctx!.fill()

      ctx!.restore()
    }

    function update() {
      // 补充花瓣
      while (petals.length < MAX_PETALS) {
        petals.push(createPetal())
      }

      for (const p of petals) {
        p.y += p.speedY
        p.x += p.speedX + Math.sin(p.swayOffset) * 0.3
        p.angle += p.spin
        p.swayOffset += p.swaySpeed
      }

      // 移除超出画面的花瓣
      petals = petals.filter((p) => p.y < h + 20 && p.x > -20 && p.x < w + 20)
    }

    function render() {
      ctx!.clearRect(0, 0, w, h)
      for (const p of petals) {
        drawPetal(p)
      }
    }

    function loop() {
      update()
      render()
      animId = requestAnimationFrame(loop)
    }

    // Reduced motion: 不播放动画
    const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)')
    function handleMotionPref() {
      if (prefersReduced.matches) {
        cancelAnimationFrame(animId)
        ctx!.clearRect(0, 0, w, h)
      } else {
        resize()
        petals = []
        loop()
      }
    }

    resize()
    window.addEventListener('resize', resize)
    prefersReduced.addEventListener('change', handleMotionPref)

    if (!prefersReduced.matches) {
      loop()
    }
  }

  initSakura()
  document.addEventListener('astro:page-load', initSakura)
</script>

<style>
  #sakura-canvas {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 9998;
  }
</style>
