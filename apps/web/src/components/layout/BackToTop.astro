---
const isHome = Astro.url.pathname === '/'
---

<div class="floating-actions" data-home={isHome ? '' : undefined}>
  <button id="toc-toggle" class="floating-btn toc-toggle" aria-label="目录" title="目录" hidden>
    <svg
      width="22"
      height="22"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    >
      <line x1="8" y1="6" x2="21" y2="6"></line>
      <line x1="8" y1="12" x2="21" y2="12"></line>
      <line x1="8" y1="18" x2="21" y2="18"></line>
      <line x1="3" y1="6" x2="3.01" y2="6"></line>
      <line x1="3" y1="12" x2="3.01" y2="12"></line>
      <line x1="3" y1="18" x2="3.01" y2="18"></line>
    </svg>
  </button>

  {
    !isHome && (
      <a class="floating-btn home-btn" href="/" aria-label="返回首页" title="返回首页">
        <svg
          width="22"
          height="22"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <path d="M3 10.5 12 3l9 7.5" />
          <path d="M5 9.5V21h14V9.5" />
        </svg>
      </a>
    )
  }

  <button id="back-to-top" class="floating-btn back-to-top" aria-label="返回顶部" title="返回顶部">
    <svg class="progress-ring" viewBox="0 0 52 52" fill="none">
      <rect class="progress-track" x="1.5" y="1.5" width="49" height="49" rx="6.5" ry="6.5"></rect>
      <rect class="progress-bar" x="1.5" y="1.5" width="49" height="49" rx="6.5" ry="6.5"></rect>
    </svg>
    <svg
      class="arrow-icon"
      width="28"
      height="28"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    >
      <polyline points="18 15 12 9 6 15"></polyline>
    </svg>
  </button>

  <div id="toc-flyout" class="toc-flyout" hidden>
    <div class="toc-flyout-inner" id="toc-flyout-inner"></div>
  </div>
</div>

<script>
  interface TsukiBackToTopWindow extends Window {
    __tsukiBackToTopCleanup?: () => void
    __tsukiBackToTopBound?: boolean
  }

  const tsukiWindow = window as TsukiBackToTopWindow

  function initBackToTop() {
    tsukiWindow.__tsukiBackToTopCleanup?.()

    const wrapper = document.querySelector('.floating-actions') as HTMLDivElement | null
    const btn = document.getElementById('back-to-top') as HTMLButtonElement | null
    const tocBtn = document.getElementById('toc-toggle') as HTMLButtonElement | null
    const tocFlyout = document.getElementById('toc-flyout') as HTMLDivElement | null
    const tocFlyoutInner = document.getElementById('toc-flyout-inner') as HTMLDivElement | null
    if (!wrapper || !btn) return

    const progressBar = btn.querySelector('.progress-bar') as SVGRectElement | null
    if (!progressBar) return

    const controller = new AbortController()
    const signal = controller.signal

    const perimeter = progressBar.getTotalLength()
    progressBar.style.strokeDasharray = `${perimeter}`
    progressBar.style.strokeDashoffset = `${perimeter}`

    let visible = false
    const threshold = 450

    const update = () => {
      const scrollY = window.scrollY
      const shouldShow = scrollY > threshold

      if (shouldShow !== visible) {
        visible = shouldShow
        btn.classList.toggle('visible', visible)
      }

      const docHeight = document.documentElement.scrollHeight - window.innerHeight
      if (docHeight > 0) {
        const progress = Math.max(0, Math.min(scrollY / docHeight, 1))
        const offset = perimeter * (1 - progress)
        progressBar.style.strokeDashoffset = `${offset}`
      }
    }

    const alignToContent = () => {
      const grid = document.querySelector('.tsuki-main-grid')
      if (!grid) return
      const rect = grid.getBoundingClientRect()
      const paddingRight = parseFloat(getComputedStyle(grid).paddingRight) || 0
      const contentRight = rect.right - paddingRight
      const rightOffset = document.documentElement.clientWidth - contentRight
      wrapper.style.right = `${Math.max(rightOffset, 16)}px`
    }

    const setupToc = () => {
      if (!tocBtn || !tocFlyout || !tocFlyoutInner) return
      const tocLinks = Array.from(
        document.querySelectorAll('#toc-list .toc-link')
      ) as HTMLAnchorElement[]
      const isMobile = window.matchMedia('(max-width: 767px)').matches

      if (!isMobile || tocLinks.length === 0) {
        tocBtn.hidden = true
        tocFlyout.hidden = true
        tocFlyout.classList.remove('open')
        return
      }

      tocBtn.hidden = false
      tocFlyoutInner.innerHTML = tocLinks
        .map(
          (link) =>
            `<a class="toc-flyout-link" href="${link.getAttribute('href')}">${link.textContent ?? ''}</a>`
        )
        .join('')

      tocFlyoutInner.querySelectorAll('a').forEach((link) => {
        link.addEventListener(
          'click',
          () => {
            tocFlyout.classList.remove('open')
            tocFlyout.hidden = true
          },
          { signal }
        )
      })
    }

    window.addEventListener('scroll', update, { passive: true, signal })
    window.addEventListener(
      'resize',
      () => {
        alignToContent()
        setupToc()
      },
      { passive: true, signal }
    )

    update()
    alignToContent()
    setupToc()

    tocBtn?.addEventListener(
      'click',
      () => {
        if (!tocFlyout) return
        const willOpen = !tocFlyout.classList.contains('open')
        tocFlyout.hidden = !willOpen
        tocFlyout.classList.toggle('open', willOpen)
      },
      { signal }
    )

    btn.addEventListener(
      'click',
      () => {
        const start = window.scrollY
        if (start <= 0) return
        const duration = Math.min(800, Math.max(300, start * 0.4))
        const startTime = performance.now()

        function easeOutCubic(t: number) {
          return 1 - Math.pow(1 - t, 3)
        }

        function step(now: number) {
          const elapsed = now - startTime
          const progress = Math.min(elapsed / duration, 1)
          const eased = easeOutCubic(progress)
          window.scrollTo(0, start * (1 - eased))
          if (progress < 1) {
            requestAnimationFrame(step)
          }
        }

        requestAnimationFrame(step)
      },
      { signal }
    )

    document.addEventListener(
      'click',
      (event) => {
        if (!tocFlyout || !tocBtn) return
        const target = event.target as Node
        if (tocFlyout.hidden) return
        if (!tocFlyout.contains(target) && !tocBtn.contains(target)) {
          tocFlyout.classList.remove('open')
          tocFlyout.hidden = true
        }
      },
      { signal }
    )

    tsukiWindow.__tsukiBackToTopCleanup = () => controller.abort()
  }

  if (!tsukiWindow.__tsukiBackToTopBound) {
    document.addEventListener('astro:page-load', initBackToTop)
    tsukiWindow.__tsukiBackToTopBound = true
  }

  initBackToTop()
</script>

<style>
  .floating-actions {
    position: fixed;
    right: 1.5rem;
    bottom: 1.5rem;
    z-index: 50;
    display: flex;
    flex-direction: column;
    gap: 0.625rem;
  }

  .floating-btn {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 5rem;
    height: 5rem;
    border: none;
    border-radius: 0.75rem;
    background: var(--tsuki-sidebar-card-bg, rgba(255, 255, 255, 0.85));
    color: var(--tsuki-fg);
    text-decoration: none;
    cursor: pointer;
    transition:
      opacity 0.25s ease,
      transform 0.25s ease,
      background-color 0.15s ease;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    padding: 0;
  }

  .floating-btn:hover {
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
    transform: translateY(-2px);
  }

  .back-to-top {
    opacity: 0;
    transform: translateY(12px);
    pointer-events: none;
  }

  .back-to-top.visible {
    opacity: 1;
    transform: translateY(0);
    pointer-events: auto;
  }

  .progress-ring {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }

  .progress-track {
    stroke: var(--tsuki-surface-border, rgba(0, 0, 0, 0.1));
    stroke-width: 2;
    fill: none;
  }

  .progress-bar {
    stroke: var(--tsuki-theme-accent, #a78bfa);
    stroke-width: 2.5;
    fill: none;
    transition: stroke-dashoffset 0.1s linear;
    transform-origin: center;
  }

  .arrow-icon {
    position: relative;
    z-index: 1;
  }

  .toc-toggle {
    display: none;
  }

  .toc-flyout {
    position: absolute;
    right: 0;
    bottom: calc(100% + 0.5rem);
    width: min(20rem, calc(100vw - 2rem));
    max-height: 55vh;
    overflow: auto;
    border-radius: 0.75rem;
    border: 1px solid var(--tsuki-card-border, rgba(0, 0, 0, 0.08));
    background: var(--tsuki-sidebar-card-bg, rgba(255, 255, 255, 0.95));
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
  }

  .toc-flyout-inner {
    display: flex;
    flex-direction: column;
    padding: 0.5rem;
    gap: 0.125rem;
  }

  .toc-flyout-link {
    color: var(--tsuki-fg-muted);
    text-decoration: none;
    padding: 0.5rem 0.625rem;
    border-radius: 0.5rem;
    line-height: 1.35;
    font-size: 0.875rem;
  }

  .toc-flyout-link:hover {
    background: color-mix(in oklab, var(--tsuki-theme-accent, #a78bfa) 12%, transparent);
    color: var(--tsuki-fg);
  }

  @media (max-width: 767px) {
    .floating-actions {
      gap: 0.5rem;
    }

    .floating-btn {
      width: 3.25rem;
      height: 3.25rem;
      border-radius: 0.65rem;
    }

    .arrow-icon {
      width: 20px;
      height: 20px;
    }

    .toc-toggle {
      display: inline-flex;
    }
  }
</style>
