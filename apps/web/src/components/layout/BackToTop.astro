---

---

<div
  class="floating-actions"
  data-backtotop-visible="false"
  data-show-home="false"
  data-show-toc="false"
>
  <button id="toc-toggle" class="floating-btn toc-toggle" aria-label="目录" title="目录">
    <svg
      width="22"
      height="22"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    >
      <line x1="8" y1="6" x2="21" y2="6"></line>
      <line x1="8" y1="12" x2="21" y2="12"></line>
      <line x1="8" y1="18" x2="21" y2="18"></line>
      <line x1="3" y1="6" x2="3.01" y2="6"></line>
      <line x1="3" y1="12" x2="3.01" y2="12"></line>
      <line x1="3" y1="18" x2="3.01" y2="18"></line>
    </svg>
  </button>

  <a id="go-home" class="floating-btn home-btn" href="/" aria-label="返回首页" title="返回首页">
    <svg
      width="22"
      height="22"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    >
      <path d="M3 10.5 12 3l9 7.5"></path>
      <path d="M5 9.5V21h14V9.5"></path>
    </svg>
  </a>

  <button id="back-to-top" class="floating-btn back-to-top" aria-label="返回顶部" title="返回顶部">
    <svg
      class="arrow-icon"
      width="28"
      height="28"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    >
      <polyline points="18 15 12 9 6 15"></polyline>
    </svg>
  </button>

  <div id="toc-flyout" class="toc-flyout" hidden>
    <div class="toc-flyout-inner" id="toc-flyout-inner"></div>
  </div>
</div>

<script>
  interface TsukiBackToTopWindow extends Window {
    __tsukiBackToTopCleanup?: () => void
    __tsukiBackToTopBound?: boolean
    __tsukiMovedTocPlaceholder?: Comment
    __tsukiMovedTocParent?: HTMLElement | null
    __tsukiMovedTocCard?: HTMLElement | null
  }

  const tsukiWindow = window as TsukiBackToTopWindow

  function isPostDetailPage(pathname: string) {
    return /^\/posts\/[^/]+\/?$/.test(pathname)
  }

  function restoreTocCard() {
    const card = tsukiWindow.__tsukiMovedTocCard
    const placeholder = tsukiWindow.__tsukiMovedTocPlaceholder
    const parent = tsukiWindow.__tsukiMovedTocParent

    if (!card || !placeholder || !parent) return
    parent.insertBefore(card, placeholder)
    placeholder.remove()
    tsukiWindow.__tsukiMovedTocCard = null
    tsukiWindow.__tsukiMovedTocPlaceholder = undefined
    tsukiWindow.__tsukiMovedTocParent = null
  }

  function initBackToTop() {
    tsukiWindow.__tsukiBackToTopCleanup?.()

    const wrapper = document.querySelector('.floating-actions') as HTMLDivElement | null
    const homeBtn = document.getElementById('go-home') as HTMLAnchorElement | null
    const btn = document.getElementById('back-to-top') as HTMLButtonElement | null
    const tocBtn = document.getElementById('toc-toggle') as HTMLButtonElement | null
    const tocFlyout = document.getElementById('toc-flyout') as HTMLDivElement | null
    const tocFlyoutInner = document.getElementById('toc-flyout-inner') as HTMLDivElement | null
    if (!wrapper || !btn || !homeBtn) return

    const controller = new AbortController()
    const signal = controller.signal

    let visible = false
    const threshold = 450

    const syncPageScopedActions = () => {
      const pathname = window.location.pathname
      const isHome = pathname === '/'
      wrapper.setAttribute('data-show-home', isHome ? 'false' : 'true')

      const postDetail = isPostDetailPage(pathname)
      wrapper.setAttribute('data-show-toc', postDetail ? 'true' : 'false')

      if (!postDetail) {
        restoreTocCard()
        if (tocBtn) tocBtn.classList.remove('is-active')
        if (tocFlyout) {
          tocFlyout.classList.remove('open')
          tocFlyout.hidden = true
        }
      }
    }

    const update = () => {
      const scrollY = window.scrollY
      const shouldShow = scrollY > threshold

      if (shouldShow !== visible) {
        visible = shouldShow
        btn.classList.toggle('visible', visible)
        wrapper.setAttribute('data-backtotop-visible', visible ? 'true' : 'false')
      }
    }

    const alignToContent = () => {
      const grid = document.querySelector('.tsuki-main-grid')
      if (!grid) return
      const rect = grid.getBoundingClientRect()
      const paddingRight = parseFloat(getComputedStyle(grid).paddingRight) || 0
      const contentRight = rect.right - paddingRight
      const rightOffset = document.documentElement.clientWidth - contentRight
      wrapper.style.right = `${Math.max(rightOffset, 16)}px`
    }

    const positionTocFlyout = () => {
      if (!tocFlyout || !tocBtn) return
      const rect = tocBtn.getBoundingClientRect()
      const gap = 8
      const bottom = Math.max(window.innerHeight - rect.top + gap, 16)
      tocFlyout.style.bottom = `${bottom}px`
      tocFlyout.style.right = `${Math.max(window.innerWidth - rect.right, 16)}px`
    }

    const closeToc = () => {
      if (!tocFlyout) return
      tocFlyout.classList.remove('open')
      tocFlyout.hidden = true
      tocBtn?.classList.remove('is-active')
    }

    const setupToc = () => {
      if (!tocBtn || !tocFlyout || !tocFlyoutInner) return

      const pathname = window.location.pathname
      const postDetail = isPostDetailPage(pathname)
      const isMobile = window.matchMedia('(max-width: 767px)').matches
      const tocCard = document.querySelector('.right-sidebar .toc-card') as HTMLElement | null
      const movedCard = tsukiWindow.__tsukiMovedTocCard ?? null
      const cardToUse = tocCard ?? movedCard

      const canShowTocBtn = postDetail && isMobile && Boolean(cardToUse)
      wrapper.setAttribute('data-show-toc', canShowTocBtn ? 'true' : 'false')

      if (!canShowTocBtn || !cardToUse) {
        restoreTocCard()
        tocBtn.classList.remove('is-active')
        closeToc()
        return
      }

      const activeCard = cardToUse
      if (activeCard.parentElement !== tocFlyoutInner) {
        restoreTocCard()
        const parent = activeCard.parentElement
        if (!parent) return
        const placeholder = document.createComment('tsuki-toc-placeholder')
        parent.insertBefore(placeholder, activeCard)
        tocFlyoutInner.appendChild(activeCard)
        tsukiWindow.__tsukiMovedTocCard = activeCard
        tsukiWindow.__tsukiMovedTocPlaceholder = placeholder
        tsukiWindow.__tsukiMovedTocParent = parent
      }
    }

    window.addEventListener(
      'scroll',
      () => {
        update()
        positionTocFlyout()
      },
      { passive: true, signal }
    )
    window.addEventListener(
      'resize',
      () => {
        alignToContent()
        setupToc()
        positionTocFlyout()
      },
      { passive: true, signal }
    )

    syncPageScopedActions()
    update()
    alignToContent()
    setupToc()
    positionTocFlyout()

    tocBtn?.addEventListener(
      'click',
      () => {
        if (!tocFlyout) return
        positionTocFlyout()
        const willOpen = !tocFlyout.classList.contains('open')
        tocFlyout.hidden = !willOpen
        tocFlyout.classList.toggle('open', willOpen)
      },
      { signal }
    )

    btn.addEventListener(
      'click',
      () => {
        const start = window.scrollY
        if (start <= 0) return
        const duration = Math.min(800, Math.max(300, start * 0.4))
        const startTime = performance.now()

        function easeOutCubic(t: number) {
          return 1 - Math.pow(1 - t, 3)
        }

        function step(now: number) {
          const elapsed = now - startTime
          const progress = Math.min(elapsed / duration, 1)
          const eased = easeOutCubic(progress)
          window.scrollTo(0, start * (1 - eased))
          if (progress < 1) requestAnimationFrame(step)
        }

        requestAnimationFrame(step)
      },
      { signal }
    )

    document.addEventListener(
      'click',
      (event) => {
        if (!tocFlyout || !tocBtn) return
        const target = event.target as Node
        if (tocFlyout.hidden) return
        if (!tocFlyout.contains(target) && !tocBtn.contains(target)) {
          closeToc()
        }
      },
      { signal }
    )

    tsukiWindow.__tsukiBackToTopCleanup = () => {
      closeToc()
      restoreTocCard()
      controller.abort()
    }
  }

  if (!tsukiWindow.__tsukiBackToTopBound) {
    document.addEventListener('astro:page-load', initBackToTop)
    tsukiWindow.__tsukiBackToTopBound = true
  }

  initBackToTop()
</script>

<style>
  .floating-actions {
    --fab-size: 5rem;
    --fab-gap: 0.625rem;
    position: fixed;
    right: 1.5rem;
    bottom: 1.5rem;
    z-index: 50;
    display: flex;
    flex-direction: column;
    gap: var(--fab-gap);
  }

  .floating-btn {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    width: var(--fab-size);
    height: var(--fab-size);
    border: none;
    border-radius: 0.75rem;
    background: var(--tsuki-sidebar-card-bg, rgba(255, 255, 255, 0.85));
    color: var(--tsuki-fg);
    text-decoration: none;
    cursor: pointer;
    transition:
      opacity 0.25s ease,
      transform 0.25s ease,
      background-color 0.15s ease;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    padding: 0;
  }

  .floating-btn:hover {
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
    transform: translateY(-2px);
  }

  .back-to-top {
    opacity: 0;
    transform: translateY(12px);
    pointer-events: none;
  }

  .back-to-top.visible {
    opacity: 1;
    transform: translateY(0);
    pointer-events: auto;
  }

  .floating-actions[data-show-home='false'] .home-btn {
    display: none;
  }

  .floating-actions[data-show-home='true'] .home-btn {
    display: inline-flex;
  }

  .floating-actions[data-show-toc='false'] .toc-toggle {
    display: none;
  }

  .floating-actions[data-show-toc='true'] .toc-toggle {
    display: inline-flex;
  }

  .floating-actions[data-backtotop-visible='false'] .floating-btn:not(.back-to-top) {
    transform: translateY(calc(var(--fab-size) + var(--fab-gap)));
  }

  .floating-actions[data-backtotop-visible='false'] .floating-btn:not(.back-to-top):hover {
    transform: translateY(calc(var(--fab-size) + var(--fab-gap) - 2px));
  }

  .arrow-icon {
    position: relative;
    z-index: 1;
  }

  .toc-flyout {
    position: fixed;
    width: min(18rem, calc(100vw - 2.5rem));
    max-height: min(58vh, 26rem);
    overflow: auto;
    border-radius: 0.75rem;
    border: 1px solid var(--tsuki-card-border, rgba(0, 0, 0, 0.08));
    background: var(--tsuki-sidebar-card-bg, rgba(255, 255, 255, 0.95));
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
  }

  .toc-flyout-inner {
    padding: 0.375rem;
  }

  .toc-flyout-inner :global(.toc-card) {
    margin: 0;
    border: none;
    box-shadow: none;
    background: transparent;
  }

  .toc-flyout-inner :global(.toc-link) {
    padding: 0.42rem 0.52rem;
    font-size: 0.82rem;
  }

  @media (max-width: 767px) {
    .floating-actions {
      --fab-size: 3.25rem;
      --fab-gap: 0.5rem;
    }

    .arrow-icon {
      width: 20px;
      height: 20px;
    }

    .toc-flyout {
      width: min(16rem, calc(100vw - 1.25rem));
      max-height: min(52vh, 22rem);
    }
  }
</style>
